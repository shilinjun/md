# 《代码大全》读书笔记



## 第1章：欢迎进入软件构建的世界

<img src="./image/代码大全/image-20240523103604629.png" alt="image-20240523103604629" style="zoom: 67%;" /><img src="./image/代码大全/image-20240523103751440.png" alt="image-20240523103751440" style="zoom: 67%;" />

.软件构建是软件开发的核心活动;构建活动是每个项目中唯一一项必不可少的工作。
.软件构建的主要活动包括:详细设计、编码、调试、集成、开发者测试( developer testing(包括单元测试和集成测试)。
.构建也常被称作“编码”和“编程”。
.构建活动的质量对软件的质量有着实质性的影响。



## 第2章：用隐喻来更充分地理解软件开发

软件中的书法：写作代码（像写信一样无规划的一次写完，注重可读性）

软件中的耕作法：培植系统 （一次完成一部分，添加完善到系统中）

软件的牡蛎养殖观点：系统生长（像牡蛎生成珍珠一样，先形成骨架，再完成功能）

软件构造：建造软件（对大型软件而言，规划设计和建造房子一样重要）

应用软件：智慧工具箱（应该尝试使用不同的软件开发方法，丰富自己的工具）

组合各个隐喻：使用不同的隐喻解释你想解释的方面



## 第3章：三思而后行：前期准备

1、在项目的初期、中期、后期都需要强调质量。

2、在实现一个系统之前，你需要理解“这个系统应该做什么”，以及“它该如何做到这些”。

3、准备工作很重要。在开始做一个大项目之前，应该为这个项目制订计划，这是很有意义的。

从管理的角度看，做计划意味着确定项目所需要用的时间、人数以及计算机台数。

从技术角度讲，做计划意味着弄清楚你想要建造的是什么，以防止浪费钱去建造错误的东西。

有时候用户在一开始并不完全确定自己想要的是什么，因此值得花费比理想情况下更多的力气，找出他们真正想要的东西。

但这至少比“先做一个错误的东西出来，然后扔掉，并从头来过”的成本要低廉。

4、发现错误的时间要尽可能接近引入该错误的时间。

5、花费在问题定义、需求分析、软件架构上的时间，依据项目的需要而变化。

一般说来，一个运作良好的项目会在需求、架构以及其他前期计划方面投入10%-20%的工作量和20%-30%的时间(McConnell 1998, Kruchten 2000)。

这些数字不包括详细设计的时间—那是构建活动的一部分。



## 第4章：关键的“构建”决策

编程约定：在高质量软件中，你可以看到“架构的概念完整性”与“其底层实现”之间的关系。

“实现”必须与(指导该实现的)“架构”保持一致，并且这种一致性是内在的固有的。

这正是变量名称、类的名称、子程序名称、格式约定、注释约定等这些针对“构建活动”的指导方针的关键所在。

Gries对“在一种语言上编程(programming in a language )"和“深入一种语言去编程(programming into a language”做了区分。

“在一种语言上编程”的程序员将他们的思想限制于“语言直接支持的那些构件”。如果语言工具是初级的，那么程序员的思想也是初级的。

“深入一种语言去编程”的程序员首先决定他要表达的思想是什么，然后决定如何使用特定语言提供的工具来表达这些思想。



## 第5章：软件构建中的设计

设计就是把需求分析和编码调试连在一起的活动。



### 5.1 设计中的挑战

设计是一个险恶的问题：有些问题，是得在程序运行后才能发现的

设计是个了无章法的过程：设计时会犯很多错误再改正、优劣方案之间差异很微妙，设计到什么程度、怎样才算是“好的”等等都没有指标。

设计就是确定取舍和调整顺序的过程：在各种指标间取舍，比如运行速度和占用内存、开发时间和运行速度等。

设计收到诸多约束：受软件规格和硬件条件等限制。

设计是不确定的：每个人有每个人的设计思路。

设计是一个启发式过程：在一件工作上十分奏效的工具或技术，在下一个项目上可能并不适用，所有要抱着“试试没准能行”的探索性的心态。

设计是自然而然形成的：设计是在不断的设计评估、非正式讨论、写验证代码以及修改验证代码的过程中演化和完善的



### 5.2 关键的设计概念

复杂度：

当项目因为技术原因导致失败时，往往是因为失控的复杂度。有关的软件变得极端复杂，让人无法知道它究竟是做什么的。

当没人知道对一处代码的改动会对其他代码带来什么影响时，项目也就快停止进展了。

在软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。

人类更易于理解许多项简单的信息，而不是一项复杂的信息。所有软件设计技术的目标都是把复杂问题分解成简单的部分。

子系统间的相互依赖越少，你就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情。

在更高汇聚的层次上，包(packages)提供了相同的好处。

理想的设计特征：

① 最小的复杂度：做简单易懂的设计，不要做“聪明的”设计，否则难以理解，增加了复杂度。

② 易于维护：想下后续维护的程序员看到你的代码是否会有疑问

③ 松散耦合：设计时让程序的各个组成部分之间关联最小。

通过应用类接口中的合理抽象、封装性及信息隐藏等原则，设计出相互关联尽可能最少的类。减少关联也就减少了集成、测试与维护时的工作量。

④ 可扩展性：可以改动系统的一部分而无需破坏底层结构。

⑤ 可重用性： 所设计的系统的组成部分能在其他系统中重复使用

⑥ 高扇入(本身被调用的量)：让大量的类使用给定的某个类。这意味着设计出的系统很好地利用了在较低层次上的工具类。

⑦ 低扇出(自身调用别的函数的量)：一个类里少量或者适中地使用其他类。

⑧ 可移植性：方便地移动到其他环境中

⑨ 精简性：系统没有多余部分，多余的部分也是要测试和后续维护的。

⑩ 层次性：保持系统各个分解层的层次性，使你可以在任意层面上观察系统。

⑪ 标准技术：用标准化的，常用的方法，让系统给人一种熟悉的感觉。

设计的层次

<img src="./image/代码大全/image-20240524102603093.png" alt="image-20240524102603093" style="zoom:67%;" />

① 软件系统：避免直接在这一层直接设计类，而是分成子系统和包

② 分解为子系统和包：明确分成哪些子系统、各个子系统之间的关系、各个子系统之间怎么通信。

分成各个子系统的意义就在于限制各个部分之前的通信，降低复杂度。因此要避免所有子系统都能和其他子系统通信。

<img src="./image/代码大全/image-20240524103307107.png" alt="image-20240524103307107" style="zoom:98%;" /><img src="./image/代码大全/image-20240524103336344.png" alt="image-20240524103336344" style="zoom:96%;" />

有一个很好的基本原则：像5-5这样的图，不应该出现任何环形关系。

③ 分解为类：识别出系统中所有的类，同时定义了这些类和系统其他部分打交道的细节，尤其是确定好类的接口。

④ 分解成子程序：③中已经定义了接口，这一层主要定义私有程序

⑤ 子程序内部的设计：完成具体的函数



### 5.3  设计构造块：启发式方法

由于软件设计是非确定性的（很多问题不可预见），因此，灵活熟练地运用一组有效的启发式方法(试探法)，

便成了合理的软件设计的核心工作。下面是一些常用的启发式方法：

① 找出现实世界中的对象：如果你写的是一个收银员相关的程序，可以参看现实中的收银员有哪些属性

② 形成一致的抽象：从各种细节中找出真正有影响的、共性的参数。比如基类抽象出了各个子类的共性，

类的接口让你只要关心怎么调用接口，而不用关心接口怎么实现。

③ 封装实现细节：封装填补了抽象留下的空白。抽象是说:“可以让你从高层的细节来看待一个对象。”而封装则说:

“除此之外，你不能看到对象的任何其他细节层次。”，比如函数封装让你仅关心接口怎么调用，而无需关心实现方式。

④ 当继承能简化设计时就继承：一些共性的操作，子类完全可以继承。

⑤ 隐藏秘密（信息隐藏）：一来可以降低复杂度，二来可以增加安全性和可维护性（只有类内的函数才能访问）

⑥ 找出容易改变的区域：要识别出哪部分后续可能会改变，并为改变做好准备。

⑦ 保持松散耦合：请尽量使你创建的模块不依赖或者很少依赖其他模块。让模块之间的关系像商业合作者一样彼此分离，

而不是像连体婴儿那样紧密相连。函数传参尽量少、类的public接口尽量少、尽量使用传参而不是全局变量传递数据，

让函数的传参更灵活易被识别。

⑧ 查阅常用的设计模式：使用公用的方式方法可以省下很多的理解成本

<img src="./image/代码大全/image-20240524140945813.png" alt="image-20240524140945813" style="zoom:50%;" />

⑨ 使用启发式方法的原则： 不要卡在单一的方式上，不要卡在一个问题上，可以先往下，后续再来解决这个问题。



### 5.4 设计实践

迭代：尝试从高层和底层审视问题，这有助于完善方案。有了好的方案就执行，执行中也能从中学习改善原有的方案。

分而治之：将程序分成不同区域开发

自上而下和自下而上的设计方法：自上而下的设计从某个很高的抽象层次开始。你定义出基类或其他不那么特殊的设计元

素。在开发这一设计的过程中，你逐渐增加细节的层次，找出派生类、合作类以及其他更细节的设计元素。

自下而上的设计始于细节，向一般性延伸。这种设计通常是从寻找具体对象开始，最后从细节之中生成对象以及基类。

建立试验性模型：对有疑虑的问题，写测试程序验证下

合作设计：和同时交流，评审方案等

要做多少设计才够：越多越好

记录你的设计成果：注释、文档、wiki、邮件总结等



### 5.5 对流行的设计方法的评论

介绍了一些别的书籍、文档



## 第6章：可以工作的类

### 6.1 类的基础：抽象数据类型（ADTs）

抽象数据类型(ADT, abstract data type)是指一些数据以及对这些数据所进行的操作的集合。这些操作既向程序的其余部分描述了这些数据是怎么样的，

也允许程序的其余部分改变这些数据。



**需要用到ADT的例子**

```c++
currentFont.size = 16 //将字体大小设置为16
currentFone.attribute = CurrentFont.attribute or 0x02 //将字体设置为粗体
```

上面的调用存在的问题:

1、调用方直接操作了数据成员，并且得知道操作的逻辑。

2、像这样的调用在代码中会到处都是，要修改的话就得都改一遍



**使用ADT的益处**

应该如下使用：

```c++
currentFont.setSizeInPoints(sizeInPoint)	//设置字体大小
currentFont.setBoldOn()		//设置为粗体
```

好处如下：

1、可以隐藏实现细节：使用者不需要知道怎么操作成员。

2、改动不会影响到整个程序：诸如粗体的实现方式改变，不需要调用者修改。

3、让接口提供更多的信息：setSizeInPoints这样的命名就在提醒你要注意传入数据的单位，currentFont.size = 16没有这个功能

4、更容易提高性能：当你想提高修改粗体的性能时，修改一个方法比修改一堆调用省事。

5、让程序的正确性显而易见：currentFone.attribute = CurrentFont.attribute or 0x02 比 currentFont.setBoldOn()  要容易写错

6、程序更具有自我说明性：看setBoldOn这样的名称就知道它干了啥

7、无需在程序内导出传递数据：

没有类的话，凡是想要操作currentFont的成员变量，都得把它做为入参或者把它作为全局变量。

有了类的话，类的成员函数可以直接访问类的成员变量而不用作为参数传入。

8、你可以像在现实世界中那样操作实体，而不用在底层实现上操作它：

程序的绝大部分可以使用setBoldOn这种更接近现实中的字体操作语言，而不是currentFone.attribute = CurrentFont.attribute or 0x02 这样难以理解的代码。



**更多的ADT示例**

总而言之，就是整理出一套对外的浅显易懂的接口，用户只需要调这些接口就行，而不用关心接口的实现方式。

一些建议：

1、把常见的底层数据类型创建为ADT并使用这些ADT，而不是使用底层数据类型：比如为堆栈、列表、链表创建一个类，并对外提供它的各个使用方法函数，

而不是直接使用这些数据类型。

2、把像文件这样的常用对象当做ADT：把文件操作定义成一个类的多个函数

3、简单的事情也可以当做ADT：就算是一个事物只有开关两个操作，也是可以定成类的

4、不要让ADT依赖于其存储介质：成员函数名不要带着信息，让使用者知道它存在哪里（内存还是磁盘），否则到时候改了存储方式，名称就错了



**在非面向对象环境中用ADT处理多分数据实例**

比如C语言，结构体没有成员函数的说法，这些函数均以独立的函数形式存在。

那怎么让下面的函数修改同一个字体结构体的数据呢，有以下的方法：

```c++
FONT_TYPE font1
setSizeInPoints(sizeInPoint)	//设置字体大小
setBoldOn()		//设置为粗体
```

1、增加“创建”、“删除”之类的函数，在里面创建和删除一个全局的FONET_TYPE对象，然后每个操作函数调用的时候都传一个id，用于区分操作的是哪个。

2、把每个函数的入参都改为完成的结构体FONT_TYPE，函数直接修改入参的内容，这样就不用传id了。

3、新增一个函数，指定当前操作的是FONT_TYPE结构体数组的哪个，后续的操作函数均操作这个对象。

总而言之，都不好，1需要加id，2会把FONT_TYPE暴露给用户，3增加了复杂度。



**ADT和类**

ADT的思想是类这一概念的基础，类是对ADT思想的一种实现方式。



### 6.2 良好的类接口



**好的抽象**

类的接口应该能提供一组明显相关的子程序。比如一个实现雇员的类，其中的子程序应该都和雇员有关系。

如果一个类中杂糅了很多不同功能的子程序，比如命令栈、报表、操作全局数据，那么应该考虑把他们分开到不同的更专一的类中。

下面是一些建议：

1、类的接口应该展现一致的抽象层次。

<img src="./image/代码大全/image-20240529100428264.png" alt="image-20240529100428264" style="zoom:80%;" />

这个类展现了两个ADT: Emplyee和ListContainer。出现这种混合的抽象，通常是源于程序员使用容器类或其他类库来实现内部逻辑，

但却没有把“使用类库”这一事实隐藏起来。应该修改如下：

<img src="./image/代码大全/image-20240529100635809.png" alt="image-20240529100635809" style="zoom:80%;" />

2、一定要理解类所实现的抽象是什么。

一个例子：有一个功能，需要A类的所有15个功能和B类150个功能中的的其中一个，那么如果新建一个包裹类的话，

这个类只需要对外暴露出A类的15个 + B类的1个子程序。

3、提供成对的服务。

写一个操作开的函数的时候，考虑下程序是有有必要写一个操作关的函数。

4、把不相关的信息转移到其他类。

如果你发现你的类中，一半程序在使用一半的数据，另一半程序在使用另一半数据，说明这两部分毫无关系，可以考虑拆成2个类。

5、尽可能让接口可编程，而不是表达语义。

让尽量多的错误能够被程序发现并报错，减少那些需要看注释和理解才能发现的错误。

6、谨防在修改时破坏接口的抽象。

比如在修改的时候，给雇员类加对外接口的时候，加了一堆查邮政编码的接口

7、不要添加与接口抽象不一致的公共成员。

比如在修改的时候，给雇员类加了一个插入链表节点的接口

8、同时考虑抽象性和内聚性。

抽象做的越好，类的各个函数之间的关系也应该是越紧密的。



**良好的封装**

抽象让你可以忽略实现的细节，直接调用接口来降低复杂度，而封装强行组织你看到细节。

也就是说，如果封装得好的话，你也就不得不做抽象了:laughing:。

下面是一些建议：

1、尽可能地限制成员的可访问性

没有公开必要的函数和变量，都定义成private

2、不要公开暴露成员数据

如果你向下面这样直接暴露成员变量，那别的地方将可以自由修改它们，而类甚至不知道它被修改了

```c++
float x;
float y;
float z;
```

应该改成如下：

```c++
float GetX();
float GetY();
float GetZ();
void SetX(float x);
void SetY(float y);
void SetZ(float z);
```

这样的好处是：

① 类能得知外接对变量的访问和修改 

② 向外接隐藏了变量的类型，因为类内部可能是保存成double，然后对外时转成float的

3、避免把私用的实现细节放入类的接口中。



